# FAST'26 Artifacts Evaluation for ThinkAhead

This repository contains the artifacts for the FAST'26 paper titled "How Soon is Now? Preloading Images for Virtual Disks with ThinkAhead". After `git clone`, you will see the directory structure shown below:

```txt
- FAST26_AE
  -- data
    -- eval_files
  -- fig
    -- fig2.pdf
    -- ...
  -- plot
  -- thinkahead
  -- requirements.txt
```

- `data` folder contains the data files used in the code.
- `fig` folder contains the figures generated by the code.
- `plot` contains the code like `plot_figxxx.py` to generate the figures in the paper.
- `thinkahead` contains the source code of ThinkAhead.
- `requirements.txt` lists the Python packages required to run the code.

## 1. Prerequisites

### 1.1 Testbed

We built a high-fidelity simulator to evaluate the performance of ThinkAhead, which only requires a single laboratory-level machine to run the AE.

### 1.2 Dependencies

All required software dependencies to run the scripts are listed in `requirements.txt`. Please follow [Dataset](#1-dataset) to download the dataset.

## 2. Dataset

We have open-sourced the metadata of VD creations, block I/O traces, and plot files. Please refer to [Tianchi](https://tianchi.aliyun.com/dataset/216164) for more information of our dataset.

After downloading and decompressing the dataset, put the `trace` folder and `VD_creation_meta.csv` under `FAST26_AE` directory, and put the `plot_files` folder under `FAST26_AE/data` directory.

## 3. Reproducing Figures

First, cd into the `plot` directory and install the required Python packages:

```bash
pip install -r requirements.txt
```

Note that all data files used in reproducing the figures are located in the `data/plot_files` directory. Then, you can run the following commands to generate the figures in the paper, all generated figures will be saved under the `fig` folder.

**Figure2: Cross block rate versus block size.** Run the following command: `python3 plot_fig2.py`, using the cross block rate file: `span_io_rate.npy`. The generated figure will be saved in `fig/fig2.pdf`.

**Figure 3: System VD size distribution.** Run the following command: `python3 plot_fig3.py`. The generated figure will be saved in `fig/fig3.pdf`.

**Figure 4: Ratios of image size to VD size.** Run the following command: `python3 plot_fig4.py`, using the ratio npy files: `public_image_size_ratios.npy` and `user_image_size_ratios.npy`. The generated figure will be saved in `fig/fig4.pdf`.

**Figure 5: Number of image accessed per user.** Run the following command: `python3 plot_fig5.py`. The generated figure will be saved in `fig/fig5.pdf`.

**Figure 6: Cluster counts of accessed images.** Run the following command: `python3 plot_fig6.py`, using the cluster count file: `cluster_counts.npy`. The generated figure will be saved in `fig/fig6.pdf`.

**Figure 7: Number of accessed images during a week.** Run the following command: `python3 plot_fig7.py`, using the accessed image trace: `cluster_image.json`. The generated figure will be saved in `fig/fig7.pdf`.

**Figure 8: Read ratios of different images.** Run the following command: `python3 plot_fig8.py`, using the json files of read ratios: `public_wr_ratio.json` and `user_wr_ratio.json`.The generated figure will be saved in `fig/fig8.pdf`.

**Figure 9: Read access pattern of two images.** Run the following command: `python3 plot_fig9.py`, using the I/O traces: `image1.npy` and `image2.npy`. The generated figures will be saved in `fig/fig9_a.pdf` and `fig/fig9_b.pdf`.

**Figure 10: Lazy loading latency.** Run the following command: `python3 plot_fig10.py` The generated figure will be saved in `fig/fig10.pdf`.

**Figure 11: Lazy loading ratios over time and clusters.** Run the following command: `python3 plot_fig11.py`, using the slow I/O data files: `slow_io_cluster_rate.json` and `slow_io_rate.json`. The generated figure will be saved in `fig/fig11.pdf`.

**Figure 12: Cosine similarity between two VDs of the same images.** Run the following command: `python3 plot_fig12.py`, using the cosine similarity files: `public_sim_res.npy` and `user_sim_res.npy`. The generated figure will be saved in `fig/fig12.pdf`.

**Figure 13: Access ratios of public and user-defined images.** Run the following command: `python3 plot_fig13.py`, using the access ratio files: `public_access_ratio.json` and `user_access_ratio.json`. The generated figure will be saved in `fig/fig13.pdf`.

**Figure 14: VD creation counts and cumulative ratio of top 100 images.** Run the following command: `python3 plot_fig14.py`, using the top-100 VD creation count file: `top100_creation.npy`. The generated figure will be saved in `fig/fig14.pdf`.

**Figure 15: Interval between a VD creation and the first read I/O.** Run the following command: `python3 plot_fig15.py`, using the I/O interval files: `public_start_time.json` and `user_start_time.json`. The generated figure will be saved in `fig/fig15.pdf`.

**Figure 16: Access pattern deviations for two VDs created from the same image.** Run the following command: `python3 plot_fig16.py`, using the block access series: `VD1.npy` and `VD2.npy`. The generated figures will be saved in `fig/fig16_a.pdf` and `fig/fig16_b.pdf`.

**Figure 17: OSS bandwidth of five EBS clusters.** Run the following command: `python3 plot_fig17.py`, using the cluster bandwidth file: `cluster_bandwidth.json`. The generated figure will be saved in `fig/fig17.pdf`.

**Figure 18: Interval between two read I/Os.** Run the following command: `python3 plot_fig18.py`, using the I/O interval files: `public_interval.npy` and `user_interval.npy`. Note that these two files should be downloaded from Tianchi and put in the `data/plot_files` folder. The generated figure will be saved in `fig/fig18.pdf`.

We also provide the source code and experiment results to reproduce the evaluation figures in our paper as follows:

**Figure 24: Performance across various network bandwidth conditions for public (left) and user-defined (right) image.** Run the following command `python3 plot_fig24.py`, which uses the json files (e.g., `few-shot_lazyload_hit_rate_2MB.json`) of each baseline under different evaluated metrics (e.g., hit rate). The generated figures will be saved in `fig/fig24_a.pdf`, `fig/fig24_b.pdf`, `fig/fig24_c.pdf`, and `fig/fig24_d.pdf`.

**Figure 25: Overall performance with sufficient training data.** Run the following command `python3 plot_fig25_26.py -a lazyload leap random greedy union-min union-avg topn io_count_time_0.5 io_count_two_time_0.5_0.3 thinkahead -bw 2 4 6 8 10 30 50 70 90 150 -m few_shot`, using the result files in `data/plot_files/few_shot`. The generated figure will be saved in `fig/fig25_hit_rate.pdf` and `fig/fig25_p50_wait_latency.pdf`.

**Figure 26: Overall performance for zero-shot scenarios.** Run the following command `python3 plot_fig25_26.py -a lazyload leap random greedy union-min union-avg topn io_count_time_0.5 io_count_two_time_0.1_0.2 thinkahead -bw 2 4 6 8 10 30 50 70 90 150 -m zero_shot`, using the result files in `data/plot_files/zero_shot`. The generated figure will be saved in `fig/fig26_hit_rate.pdf` and `fig/fig26_p50_wait_latency.pdf`.

**Figure 27: Training (left) and inference (right) overhead.** Run the following command `python3 plot_fig27.py`. The generated figure will be saved in `fig/fig27.pdf`.

**Figure 28: Simulations with real-world network conditions.** Run the following command `python3 plot_fig28.py -a lazyload leap random greedy union io_count_time thinkahead`, which uses the result files in `data/plot_files/real_world`. The generated figure will be saved in `fig/fig28_hit_rate.pdf` and `fig/fig28_wait_latency`.

**Figure 29: Ablation study.** Run the following command `python3 plot_fig29.py`. The generated figure will be saved in `fig/fig29.pdf`.

**Figure 30: Relative end-to-end performance in the experimental cluster.** Run the following command `python3 plot_fig30.py`. The generated figure will be saved in `fig/fig30.pdf`.

## 4. Reproducing Experiments

### 4.1 Quick Start

Since the entires training procedure takes ~1 day for a single machine, and the trained parameters could be various due to randomness, we provide trained model parameters in the `thinkahead/param` directory to reproduce results.

- To reproduce the overall performance results with sufficient training data of ThinkAhead in the paper (Figure 25), run the following command. The average hit rate and p50 wait latency should be printed out. The running log can be found under `log/sufficient/`, and the results can be found under `result/sufficient`.

    ```bash
    # The bandwidth can be set to
    # [2, 4, 6, 8, 10, 30, 50, 70, 90, 150]
    cd thinkahead && python3 sufficient_thinkahead.py -bw 2 -m test
    ```

- To reproduce the zero-shot results of ThinkAhead in the paper (Figure 26), run the following command. The average hit rate and p50 wait latency should be printed out. The running log can be found under `log/zero_shot/`, and the results can be found under `result/zero_shot`.

    ```bash
    # The bandwidth can be set to 
    # [2, 4, 6, 8, 10, 30, 50, 70, 90, 150]
    cd thinkahead && python3 zero_shot_thinkahead.py -bw 2
    ```

- To reproduce the real-world simulation results of ThinkAhead in the paper (Figure 28), run the following command. The results can be found under `results/real_world`.

    ```bash
    cd thinkahead && python3 real_world_eval.py
    ```

### 4.2 Train from Scratch

To train a ThinkAhead model using genetic algorithm from scratch, run the following command. The generated parameter files will be saved in the `./data/eval_files/params` directory.

**Note:** This procedure may take a long time and will override the provided trained parameter files.

```bash
# The bandwidth can be set to 
# [2, 4, 6, 8, 10, 30, 50, 70, 90, 150]
cd thinkahead && python3 sufficient_thinkahead.py -bw 2 -m train
```

## 5. Publication

If you find ThinkAhead useful, please consider citing our paper:

```bibtex
@inproceedings{ThinkAhead2026FAST,
  author = {Chen, Xinqi and Zhang, Yu and Xu, Erci and Wang, Changhong and Yi, Jifei and Wang, Qiuping and Sun, Shizhuo and Wang, Zhongyu and Wu, Haonan and Wu, Junping and Peng, Hailin and Liu, Rong and Wang, Yinhu and Zhu, Jiaji and Wu, Jiesheng and Xue, Guangtao and Lee, Patrick P. C.},
  title = {How Soon is Now? Preloading Images for Virtual Disks with ThinkAhead},
  booktitle = {Proceedings of the 24th USENIX Conference on File and Storage Technologies (FAST)},
  year = {2026}
}
```
